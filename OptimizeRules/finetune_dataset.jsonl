{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization rule identifies and propagates compile-time constants through the design, eliminating unnecessary logic operations and reducing overall circuit complexity.\n\nCode:\n```verilog\nmodule example_before (\n    input clk,\n    input rst,\n    output reg [7:0] result\n);\n    parameter ENABLE = 1'b1;\n    parameter OFFSET = 8'd10;\n    \n    reg [7:0] temp1, temp2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            temp1 <= 8'd0;\n            temp2 <= 8'd0;\n            result <= 8'd0;\n        end else begin\n            if (ENABLE) begin\n                temp1 <= OFFSET + 8'd5;\n                temp2 <= temp1 * 2;\n                result <= temp2;\n            end else begin\n                result <= 8'd0;  // Dead code since ENABLE is always 1\n            end\n        end\n    end\nendmodule\n```", "output": "module example_after (\n    input clk,\n    input rst,\n    output reg [7:0] result\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else begin\n            result <= 8'd30;  // (10 + 5) * 2 = 30, precomputed\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization identifies arithmetic operations, comparators, and other functional units that are not used simultaneously and merges them into shared resources with appropriate multiplexing logic.\n\nCode:\n```verilog\nmodule resource_before (\n    input clk,\n    input rst,\n    input [7:0] a, b, c, d,\n    input mode,\n    output reg [15:0] result1, result2\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            result1 <= 16'd0;\n            result2 <= 16'd0;\n        end else begin\n            if (mode) begin\n                result1 <= a * b;     // Multiplier 1\n                result2 <= 16'd0;\n            end else begin\n                result1 <= 16'd0;\n                result2 <= c * d;     // Multiplier 2\n            end\n        end\n    end\nendmodule\n```", "output": "module resource_after (\n    input clk,\n    input rst,\n    input [7:0] a, b, c, d,\n    input mode,\n    output reg [15:0] result1, result2\n);\n    // Shared multiplier inputs\n    reg [7:0] mult_in1, mult_in2;\n    wire [15:0] mult_out;\n    \n    // Shared multiplier\n    assign mult_out = mult_in1 * mult_in2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            result1 <= 16'd0;\n            result2 <= 16'd0;\n            mult_in1 <= 8'd0;\n            mult_in2 <= 8'd0;\n        end else begin\n            if (mode) begin\n                mult_in1 <= a;\n                mult_in2 <= b;\n                result1 <= mult_out;\n                result2 <= 16'd0;\n            end else begin\n                mult_in1 <= c;\n                mult_in2 <= d;\n                result1 <= 16'd0;\n                result2 <= mult_out;\n            end\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization identifies arithmetic operations, comparators, and other functional units that are not used simultaneously and merges them into shared resources with appropriate multiplexing logic.\n\nCode:\n```verilog\nmodule multi_ops_before (\n    input clk, rst,\n    input [15:0] x, y, z,\n    input [1:0] op_sel,\n    output reg [15:0] out1, out2, out3\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            out1 <= 16'd0;\n            out2 <= 16'd0; \n            out3 <= 16'd0;\n        end else begin\n            case (op_sel)\n                2'b00: out1 <= x + y;       // Adder 1\n                2'b01: out2 <= y + z;       // Adder 2  \n                2'b10: out3 <= x + z;       // Adder 3\n                default: begin\n                    out1 <= 16'd0;\n                    out2 <= 16'd0;\n                    out3 <= 16'd0;\n                end\n            endcase\n        end\n    end\nendmodule\n```", "output": "module multi_ops_after (\n    input clk, rst,\n    input [15:0] x, y, z,\n    input [1:0] op_sel,\n    output reg [15:0] out1, out2, out3\n);\n    // Shared adder\n    reg [15:0] add_in1, add_in2;\n    wire [15:0] add_out;\n    \n    assign add_out = add_in1 + add_in2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            out1 <= 16'd0;\n            out2 <= 16'd0;\n            out3 <= 16'd0;\n            add_in1 <= 16'd0;\n            add_in2 <= 16'd0;\n        end else begin\n            case (op_sel)\n                2'b00: begin\n                    add_in1 <= x;\n                    add_in2 <= y;\n                    out1 <= add_out;\n                    out2 <= 16'd0;\n                    out3 <= 16'd0;\n                end\n                2'b01: begin\n                    add_in1 <= y;\n                    add_in2 <= z;\n                    out1 <= 16'd0;\n                    out2 <= add_out;\n                    out3 <= 16'd0;\n                end\n                2'b10: begin\n                    add_in1 <= x;\n                    add_in2 <= z;\n                    out1 <= 16'd0;\n                    out2 <= 16'd0;\n                    out3 <= add_out;\n                end\n                default: begin\n                    out1 <= 16'd0;\n                    out2 <= 16'd0;\n                    out3 <= 16'd0;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization automatically inserts clock gating cells to disable clock signals to registers when they are not being updated, significantly reducing dynamic power consumption in sequential logic.\n\nCode:\n```verilog\nmodule clock_before (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] data_in,\n    output reg [31:0] data_out,\n    output reg [15:0] counter,\n    output reg [7:0] status\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 32'd0;\n            counter <= 16'd0;\n            status <= 8'd0;\n        end else begin\n            if (enable) begin\n                data_out <= data_in;\n                counter <= counter + 1;\n                status <= status + 1;\n            end\n            // Registers still toggle on every clock edge\n            // even when enable is low\n        end\n    end\nendmodule\n```", "output": "module clock_after (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] data_in,\n    output reg [31:0] data_out,\n    output reg [15:0] counter,\n    output reg [7:0] status\n);\n    // Clock gating logic\n    wire enable_qualified;\n    wire gated_clk;\n    \n    // Qualify enable with reset for proper gating\n    assign enable_qualified = enable && !rst;\n    \n    // Clock gating cell (latch + AND gate)\n    reg enable_latch;\n    always @(clk or enable_qualified) begin\n        if (!clk)\n            enable_latch <= enable_qualified;\n    end\n    \n    assign gated_clk = clk && enable_latch;\n    \n    // Registers using gated clock\n    always @(posedge gated_clk) begin\n        if (rst) begin\n            data_out <= 32'd0;\n            counter <= 16'd0;\n            status <= 8'd0;\n        end else begin\n            data_out <= data_in;\n            counter <= counter + 1;\n            status <= status + 1;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization automatically inserts clock gating cells to disable clock signals to registers when they are not being updated, significantly reducing dynamic power consumption in sequential logic.\n\nCode:\n```verilog\nmodule processor_before (\n    input clk, rst,\n    input cpu_enable, fpu_enable, cache_enable,\n    input [31:0] instruction,\n    output reg [31:0] cpu_result,\n    output reg [63:0] fpu_result,\n    output reg [31:0] cache_data\n);\n    // CPU registers\n    reg [31:0] cpu_reg [0:31];\n    reg [31:0] pc;\n    \n    // FPU registers  \n    reg [63:0] fpu_reg [0:15];\n    reg [31:0] fpu_control;\n    \n    // Cache registers\n    reg [31:0] cache_tag [0:255];\n    reg [31:0] cache_data_array [0:255];\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            // Reset all registers\n            cpu_result <= 32'd0;\n            fpu_result <= 64'd0;\n            cache_data <= 32'd0;\n            pc <= 32'd0;\n            fpu_control <= 32'd0;\n        end else begin\n            if (cpu_enable) begin\n                // CPU operations\n                cpu_result <= cpu_reg[instruction[19:15]];\n                pc <= pc + 4;\n            end\n            \n            if (fpu_enable) begin\n                // FPU operations\n                fpu_result <= fpu_reg[instruction[11:8]];\n                fpu_control <= fpu_control | instruction[7:0];\n            end\n            \n            if (cache_enable) begin\n                // Cache operations\n                cache_data <= cache_data_array[instruction[7:0]];\n            end\n        end\n    end\nendmodule\n```", "output": "module processor_after (\n    input clk, rst,\n    input cpu_enable, fpu_enable, cache_enable,\n    input [31:0] instruction,\n    output reg [31:0] cpu_result,\n    output reg [63:0] fpu_result,\n    output reg [31:0] cache_data\n);\n    // Clock gating for different functional units\n    wire cpu_gated_clk, fpu_gated_clk, cache_gated_clk;\n    \n    // CPU clock gating\n    reg cpu_enable_latch;\n    always @(clk or cpu_enable) begin\n        if (!clk) cpu_enable_latch <= cpu_enable && !rst;\n    end\n    assign cpu_gated_clk = clk && cpu_enable_latch;\n    \n    // FPU clock gating\n    reg fpu_enable_latch;\n    always @(clk or fpu_enable) begin\n        if (!clk) fpu_enable_latch <= fpu_enable && !rst;\n    end\n    assign fpu_gated_clk = clk && fpu_enable_latch;\n    \n    // Cache clock gating\n    reg cache_enable_latch;\n    always @(clk or cache_enable) begin\n        if (!clk) cache_enable_latch <= cache_enable && !rst;\n    end\n    assign cache_gated_clk = clk && cache_enable_latch;\n    \n    // CPU registers with gated clock\n    reg [31:0] cpu_reg [0:31];\n    reg [31:0] pc;\n    \n    always @(posedge cpu_gated_clk) begin\n        if (rst) begin\n            cpu_result <= 32'd0;\n            pc <= 32'd0;\n        end else begin\n            cpu_result <= cpu_reg[instruction[19:15]];\n            pc <= pc + 4;\n        end\n    end\n    \n    // FPU registers with gated clock\n    reg [63:0] fpu_reg [0:15];\n    reg [31:0] fpu_control;\n    \n    always @(posedge fpu_gated_clk) begin\n        if (rst) begin\n            fpu_result <= 64'd0;\n            fpu_control <= 32'd0;\n        end else begin\n            fpu_result <= fpu_reg[instruction[11:8]];\n            fpu_control <= fpu_control | instruction[7:0];\n        end\n    end\n    \n    // Cache registers with gated clock\n    reg [31:0] cache_tag [0:255];\n    reg [31:0] cache_data_array [0:255];\n    \n    always @(posedge cache_gated_clk) begin\n        if (rst) begin\n            cache_data <= 32'd0;\n        end else begin\n            cache_data <= cache_data_array[instruction[7:0]];\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization automatically identifies long combinational paths and inserts pipeline registers to break them into shorter stages, enabling higher operating frequencies and better throughput.\n\nCode:\n```verilog\nmodule multiplier_before (\n    input clk,\n    input rst,\n    input [15:0] a, b,\n    input start,\n    output reg [31:0] result,\n    output reg done\n);\n    // Single-cycle 16x16 multiplier (long critical path)\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 32'd0;\n            done <= 1'b0;\n        end else begin\n            if (start) begin\n                result <= a * b;  // Critical path: ~15-20ns\n                done <= 1'b1;\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\nendmodule\n```", "output": "module multiplier_after (\n    input clk,\n    input rst,\n    input [15:0] a, b,\n    input start,\n    output reg [31:0] result,\n    output reg done\n);\n    // 3-stage pipelined multiplier\n    reg [15:0] a_stage1, b_stage1;\n    reg [31:0] partial_stage1, partial_stage2;\n    reg start_stage1, start_stage2, start_stage3;\n    \n    // Stage 1: Input registration and partial products\n    always @(posedge clk) begin\n        if (rst) begin\n            a_stage1 <= 16'd0;\n            b_stage1 <= 16'd0;\n            partial_stage1 <= 32'd0;\n            start_stage1 <= 1'b0;\n        end else begin\n            a_stage1 <= a;\n            b_stage1 <= b;\n            // First partial product (lower 8x8)\n            partial_stage1 <= a[7:0] * b[7:0];\n            start_stage1 <= start;\n        end\n    end\n    \n    // Stage 2: Middle partial products\n    always @(posedge clk) begin\n        if (rst) begin\n            partial_stage2 <= 32'd0;\n            start_stage2 <= 1'b0;\n        end else begin\n            // Combine partial products\n            partial_stage2 <= partial_stage1 + \n                             (a_stage1[15:8] * b_stage1[7:0] << 8) +\n                             (a_stage1[7:0] * b_stage1[15:8] << 8);\n            start_stage2 <= start_stage1;\n        end\n    end\n    \n    // Stage 3: Final result\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 32'd0;\n            done <= 1'b0;\n            start_stage3 <= 1'b0;\n        end else begin\n            // Final partial product\n            result <= partial_stage2 + \n                     (a_stage1[15:8] * b_stage1[15:8] << 16);\n            start_stage3 <= start_stage2;\n            done <= start_stage3;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization automatically identifies long combinational paths and inserts pipeline registers to break them into shorter stages, enabling higher operating frequencies and better throughput.\n\nCode:\n```verilog\nmodule dsp_before (\n    input clk, rst,\n    input [15:0] x_in,\n    input [15:0] coeff [0:7],\n    output reg [31:0] y_out\n);\n    // Single-cycle FIR filter (very long critical path)\n    always @(posedge clk) begin\n        if (rst) begin\n            y_out <= 32'd0;\n        end else begin\n            // All operations in single cycle - critical path ~30-40ns\n            y_out <= (x_in * coeff[0]) + \n                     (x_in * coeff[1]) + \n                     (x_in * coeff[2]) + \n                     (x_in * coeff[3]) + \n                     (x_in * coeff[4]) + \n                     (x_in * coeff[5]) + \n                     (x_in * coeff[6]) + \n                     (x_in * coeff[7]);\n        end\n    end\nendmodule\n```", "output": "module dsp_after (\n    input clk, rst,\n    input [15:0] x_in,\n    input [15:0] coeff [0:7],\n    output reg [31:0] y_out\n);\n    // 4-stage pipelined FIR filter\n    \n    // Stage 1: Input registration and first 2 multiplications\n    reg [15:0] x_reg1;\n    reg [31:0] mult01_reg1, mult23_reg1;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            x_reg1 <= 16'd0;\n            mult01_reg1 <= 32'd0;\n            mult23_reg1 <= 32'd0;\n        end else begin\n            x_reg1 <= x_in;\n            mult01_reg1 <= (x_in * coeff[0]) + (x_in * coeff[1]);\n            mult23_reg1 <= (x_in * coeff[2]) + (x_in * coeff[3]);\n        end\n    end\n    \n    // Stage 2: Next 2 multiplications and partial sum\n    reg [31:0] mult45_reg2, mult67_reg2;\n    reg [31:0] sum01_reg2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            mult45_reg2 <= 32'd0;\n            mult67_reg2 <= 32'd0;\n            sum01_reg2 <= 32'd0;\n        end else begin\n            mult45_reg2 <= (x_reg1 * coeff[4]) + (x_reg1 * coeff[5]);\n            mult67_reg2 <= (x_reg1 * coeff[6]) + (x_reg1 * coeff[7]);\n            sum01_reg2 <= mult01_reg1 + mult23_reg1;\n        end\n    end\n    \n    // Stage 3: Intermediate sum\n    reg [31:0] sum45_reg3, sum_low_reg3;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            sum45_reg3 <= 32'd0;\n            sum_low_reg3 <= 32'd0;\n        end else begin\n            sum45_reg3 <= mult45_reg2 + mult67_reg2;\n            sum_low_reg3 <= sum01_reg2;\n        end\n    end\n    \n    // Stage 4: Final result\n    always @(posedge clk) begin\n        if (rst) begin\n            y_out <= 32'd0;\n        end else begin\n            y_out <= sum_low_reg3 + sum45_reg3;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes memory access patterns and reorganizes memory structures to improve efficiency through banking, merging, splitting, and access pattern optimization.\n\nCode:\n```verilog\nmodule memory_before (\n    input clk,\n    input rst,\n    input [7:0] addr_a, addr_b,\n    input [31:0] data_in_a, data_in_b,\n    input we_a, we_b,\n    output reg [31:0] data_out_a, data_out_b\n);\n    // Two separate single-port memories\n    reg [31:0] memory_a [0:255];\n    reg [31:0] memory_b [0:255];\n    \n    // Memory A\n    always @(posedge clk) begin\n        if (we_a) begin\n            memory_a[addr_a] <= data_in_a;\n        end\n        data_out_a <= memory_a[addr_a];\n    end\n    \n    // Memory B  \n    always @(posedge clk) begin\n        if (we_b) begin\n            memory_b[addr_b] <= data_in_b;\n        end\n        data_out_b <= memory_b[addr_b];\n    end\nendmodule\n```", "output": "module memory_after (\n    input clk,\n    input rst,\n    input [7:0] addr_a, addr_b,\n    input [31:0] data_in_a, data_in_b,\n    input we_a, we_b,\n    output reg [31:0] data_out_a, data_out_b\n);\n    // Single dual-port memory (area and power efficient)\n    reg [31:0] dual_port_memory [0:255];\n    \n    // Port A\n    always @(posedge clk) begin\n        if (we_a) begin\n            dual_port_memory[addr_a] <= data_in_a;\n        end\n        data_out_a <= dual_port_memory[addr_a];\n    end\n    \n    // Port B\n    always @(posedge clk) begin\n        if (we_b) begin\n            dual_port_memory[addr_b] <= data_in_b;\n        end\n        data_out_b <= dual_port_memory[addr_b];\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes memory access patterns and reorganizes memory structures to improve efficiency through banking, merging, splitting, and access pattern optimization.\n\nCode:\n```verilog\nmodule cache_before (\n    input clk, rst,\n    input [15:0] addr,\n    input [127:0] data_in,\n    input [3:0] byte_enable,\n    input read_en, write_en,\n    output reg [127:0] data_out,\n    output reg hit\n);\n    // Single large memory - bank conflicts\n    reg [127:0] cache_memory [0:1023];\n    reg [15:0] tag_memory [0:1023];\n    reg valid_memory [0:1023];\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 128'd0;\n            hit <= 1'b0;\n        end else begin\n            if (read_en || write_en) begin\n                if (valid_memory[addr[9:0]] && \n                    tag_memory[addr[9:0]] == addr[15:10]) begin\n                    hit <= 1'b1;\n                    if (write_en) begin\n                        // Byte-level writes are inefficient\n                        if (byte_enable[0]) \n                            cache_memory[addr[9:0]][31:0] <= data_in[31:0];\n                        if (byte_enable[1]) \n                            cache_memory[addr[9:0]][63:32] <= data_in[63:32];\n                        if (byte_enable[2]) \n                            cache_memory[addr[9:0]][95:64] <= data_in[95:64];\n                        if (byte_enable[3]) \n                            cache_memory[addr[9:0]][127:96] <= data_in[127:96];\n                    end else begin\n                        data_out <= cache_memory[addr[9:0]];\n                    end\n                end else begin\n                    hit <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n```", "output": "module cache_after (\n    input clk, rst,\n    input [15:0] addr,\n    input [127:0] data_in,\n    input [3:0] byte_enable,\n    input read_en, write_en,\n    output reg [127:0] data_out,\n    output reg hit\n);\n    // Banked memory architecture - 4 banks of 32-bit each\n    reg [31:0] cache_bank0 [0:1023];\n    reg [31:0] cache_bank1 [0:1023];\n    reg [31:0] cache_bank2 [0:1023];\n    reg [31:0] cache_bank3 [0:1023];\n    \n    // Shared tag and valid arrays\n    reg [15:0] tag_memory [0:1023];\n    reg valid_memory [0:1023];\n    \n    // Bank outputs\n    wire [31:0] bank_out [0:3];\n    assign bank_out[0] = cache_bank0[addr[9:0]];\n    assign bank_out[1] = cache_bank1[addr[9:0]];\n    assign bank_out[2] = cache_bank2[addr[9:0]];\n    assign bank_out[3] = cache_bank3[addr[9:0]];\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 128'd0;\n            hit <= 1'b0;\n        end else begin\n            if (read_en || write_en) begin\n                if (valid_memory[addr[9:0]] && \n                    tag_memory[addr[9:0]] == addr[15:10]) begin\n                    hit <= 1'b1;\n                    \n                    if (write_en) begin\n                        // Efficient banked writes\n                        if (byte_enable[0]) \n                            cache_bank0[addr[9:0]] <= data_in[31:0];\n                        if (byte_enable[1]) \n                            cache_bank1[addr[9:0]] <= data_in[63:32];\n                        if (byte_enable[2]) \n                            cache_bank2[addr[9:0]] <= data_in[95:64];\n                        if (byte_enable[3]) \n                            cache_bank3[addr[9:0]] <= data_in[127:96];\n                    end else begin\n                        // Parallel read from all banks\n                        data_out <= {bank_out[3], bank_out[2], \n                                    bank_out[1], bank_out[0]};\n                    end\n                    \n                    if (write_en) begin\n                        tag_memory[addr[9:0]] <= addr[15:10];\n                        valid_memory[addr[9:0]] <= 1'b1;\n                    end\n                end else begin\n                    hit <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes memory access patterns and reorganizes memory structures to improve efficiency through banking, merging, splitting, and access pattern optimization.\n\nCode:\n```verilog\nmodule processor_mem_before (\n    input clk, rst,\n    input [31:0] pc,\n    input [31:0] mem_addr,\n    input mem_read, mem_write,\n    input [31:0] mem_data_in,\n    output reg [31:0] instruction,\n    output reg [31:0] mem_data_out\n);\n    // Single large memory for everything\n    reg [31:0] main_memory [0:65535];\n    \n    always @(posedge clk) begin\n        // Instruction fetch\n        instruction <= main_memory[pc[17:2]];\n        \n        // Data access\n        if (mem_write) begin\n            main_memory[mem_addr[17:2]] <= mem_data_in;\n        end else if (mem_read) begin\n            mem_data_out <= main_memory[mem_addr[17:2]];\n        end\n    end\nendmodule\n```", "output": "module processor_mem_after (\n    input clk, rst,\n    input [31:0] pc,\n    input [31:0] mem_addr,\n    input mem_read, mem_write,\n    input [31:0] mem_data_in,\n    output reg [31:0] instruction,\n    output reg [31:0] mem_data_out\n);\n    // Separate instruction and data memories\n    reg [31:0] instruction_memory [0:4095];  // 16KB I-cache\n    reg [31:0] data_cache [0:1023];          // 4KB D-cache\n    reg [31:0] main_memory [0:16383];        // 64KB main memory\n    \n    // Cache control\n    reg [31:0] icache_tags [0:255];\n    reg icache_valid [0:255];\n    \n    // Simplified cache access logic (not fully implemented)\n    always @(posedge clk) begin\n        // Instruction fetch (simplified)\n        instruction <= instruction_memory[pc[13:2]];\n        \n        // Data access (simplified)\n        if (mem_write) begin\n            data_cache[mem_addr[11:2]] <= mem_data_in;\n        end else if (mem_read) begin\n            mem_data_out <= data_cache[mem_addr[11:2]];\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization applies advanced Boolean algebra techniques, logic restructuring, and technology mapping to minimize logic gates, reduce critical path delays, and improve overall circuit efficiency.\n\nCode:\n```verilog\nmodule logic_before (\n    input [3:0] a, b, c,\n    input sel1, sel2,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case ({sel2, sel1})\n            2'b00: result = (a & b) | (a & c) | (b & c);\n            2'b01: result = (a | b) & (a | c) & (b | c);\n            2'b10: result = a ^ b ^ c;\n            2'b11: result = ~((a & b) | (a & c) | (b & c));\n        endcase\n    end\nendmodule\n```", "output": "module logic_after (\n    input [3:0] a, b, c,\n    input sel1, sel2,\n    output reg [3:0] result\n);\n    // Optimized logic with common subexpressions\n    wire [3:0] majority_func = (a & b) | (a & c) | (b & c);\n    wire [3:0] minority_func = (a | b) & (a | c) & (b | c);\n    wire [3:0] parity_func = a ^ b ^ c;\n    wire [3:0] inv_majority = ~majority_func;\n    \n    always @(*) begin\n        case ({sel2, sel1})\n            2'b00: result = majority_func;\n            2'b01: result = minority_func;\n            2'b10: result = parity_func;\n            2'b11: result = inv_majority;\n        endcase\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization applies advanced Boolean algebra techniques, logic restructuring, and technology mapping to minimize logic gates, reduce critical path delays, and improve overall circuit efficiency.\n\nCode:\n```verilog\nmodule complex_logic_before (\n    input [7:0] x, y, z,\n    input [2:0] opcode,\n    output reg [7:0] result\n);\n    always @(*) begin\n        case (opcode)\n            3'b000: result = (x & y) | (x & z) | (y & z) | (x & y & z);\n            3'b001: result = (x | y) & (x | z) & (y | z) & (x | y | z);\n            3'b010: result = x ^ y ^ z ^ (x & y) ^ (x & z) ^ (y & z);\n            3'b011: result = ((x & y) | z) & ((x & z) | y) & ((y & z) | x);\n            3'b100: result = ~x & ~y & ~z;\n            3'b101: result = ~((x & y) | (x & z) | (y & z));\n            3'b110: result = (x & ~y) | (~x & y) | (z & (x ^ y));\n            3'b111: result = x | y | z;\n        endcase\n    end\nendmodule\n```", "output": "module complex_logic_after (\n    input [7:0] x, y, z,\n    input [2:0] opcode,\n    output reg [7:0] result\n);\n    // Pre-computed common terms\n    wire [7:0] x_and_y = x & y;\n    wire [7:0] x_and_z = x & z;\n    wire [7:0] y_and_z = y & z;\n    wire [7:0] x_or_y = x | y;\n    wire [7:0] x_or_z = x | z;\n    wire [7:0] y_or_z = y | z;\n    wire [7:0] x_xor_y = x ^ y;\n    wire [7:0] majority = x_and_y | x_and_z | y_and_z;\n    wire [7:0] any_two = (x_and_y | x_and_z | y_and_z);\n    \n    always @(*) begin\n        case (opcode)\n            3'b000: result = majority;  // Simplified\n            3'b001: result = x_or_y & x_or_z & y_or_z;  // Factored\n            3'b010: result = x ^ y ^ z ^ any_two;  // Common subexpression\n            3'b011: result = (majority | z) & (majority | y) & (majority | x);\n            3'b100: result = ~(x | y | z);  // De Morgan's law\n            3'b101: result = ~majority;  // Direct negation\n            3'b110: result = x_xor_y | (z & x_xor_y);  // Factored\n            3'b111: result = x | y | z;  // Already minimal\n        endcase\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization applies advanced Boolean algebra techniques, logic restructuring, and technology mapping to minimize logic gates, reduce critical path delays, and improve overall circuit efficiency.\n\nCode:\n```verilog\nmodule arithmetic_before (\n    input [15:0] a, b, c, d,\n    input [1:0] mode,\n    output reg [31:0] result\n);\n    always @(*) begin\n        case (mode)\n            2'b00: result = a * b + c * d;\n            2'b01: result = a * (b + c) + d;\n            2'b10: result = (a + b) * (c + d);\n            2'b11: result = a * b * c + a * b * d + a * c * d + b * c * d;\n        endcase\n    end\nendmodule\n```", "output": "module arithmetic_after (\n    input [15:0] a, b, c, d,\n    input [1:0] mode,\n    output reg [31:0] result\n);\n    // Shared arithmetic units\n    wire [31:0] ab = a * b;\n    wire [31:0] cd = c * d;\n    wire [16:0] b_plus_c = b + c;  // Extra bit for carry\n    wire [16:0] a_plus_b = a + b;\n    wire [16:0] c_plus_d = c + d;\n    wire [31:0] abc = ab * c;\n    \n    always @(*) begin\n        case (mode)\n            2'b00: result = ab + cd;  // Reuse multiplications\n            2'b01: result = a * b_plus_c + d;  // Factor multiplication\n            2'b10: result = a_plus_b * c_plus_d;  // Share additions\n            2'b11: result = abc + ab * d + a * cd + b * cd;  // Factor common terms\n        endcase\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization applies advanced Boolean algebra techniques, logic restructuring, and technology mapping to minimize logic gates, reduce critical path delays, and improve overall circuit efficiency.\n\nCode:\n```verilog\nmodule sequential_before (\n    input clk, rst,\n    input [7:0] data_in,\n    input enable,\n    output reg [7:0] data_out\n);\n    reg [7:0] stage1, stage2, stage3;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 8'd0;\n            stage2 <= 8'd0;\n            stage3 <= 8'd0;\n            data_out <= 8'd0;\n        end else if (enable) begin\n            stage1 <= data_in;\n            stage2 <= stage1;\n            stage3 <= stage2;\n            data_out <= stage3;\n        end\n    end\nendmodule\n```", "output": "module sequential_after (\n    input clk, rst,\n    input [7:0] data_in,\n    input enable,\n    output reg [7:0] data_out\n);\n    // Optimized shift register\n    reg [31:0] shift_reg;  // Pack all stages into one register\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            shift_reg <= 32'd0;\n        end else if (enable) begin\n            shift_reg <= {shift_reg[23:0], data_in};\n        end\n    end\n    \n    assign data_out = shift_reg[31:24];  // Extract output\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes and optimizes data processing paths by identifying bottlenecks, eliminating redundant operations, and restructuring data flow for better efficiency.\n\nCode:\n```verilog\nmodule datapath_before (\n    input clk, rst,\n    input [15:0] data_in,\n    input [3:0] control,\n    output reg [15:0] data_out\n);\n    // Inefficient data processing\n    reg [15:0] stage1, stage2, stage3;\n    reg [7:0] temp1, temp2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 16'd0;\n            stage2 <= 16'd0;\n            stage3 <= 16'd0;\n            data_out <= 16'd0;\n        end else begin\n            // Stage 1: Unnecessary width conversion\n            stage1 <= data_in;\n            temp1 <= data_in[7:0];\n            \n            // Stage 2: Redundant operations\n            stage2 <= stage1;\n            temp2 <= temp1;\n            \n            // Stage 3: Inefficient control logic\n            case (control)\n                4'b0001: stage3 <= stage2 + temp2;\n                4'b0010: stage3 <= stage2 - temp2;\n                4'b0100: stage3 <= stage2 & {8'hFF, temp2};\n                4'b1000: stage3 <= {temp2, stage2[7:0]};\n                default: stage3 <= stage2;\n            endcase\n            \n            data_out <= stage3;\n        end\n    end\nendmodule\n```", "output": "module datapath_after (\n    input clk, rst,\n    input [15:0] data_in,\n    input [3:0] control,\n    output reg [15:0] data_out\n);\n    // Optimized data processing\n    reg [15:0] stage1, stage2;\n    wire [15:0] processed_data;\n    \n    // Direct data processing without width conversion\n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 16'd0;\n            stage2 <= 16'd0;\n            data_out <= 16'd0;\n        end else begin\n            // Stage 1: Efficient data forwarding\n            stage1 <= data_in;\n            \n            // Stage 2: Optimized control logic\n            case (control)\n                4'b0001: stage2 <= stage1 + data_in;\n                4'b0010: stage2 <= stage1 - data_in;\n                4'b0100: stage2 <= stage1 & data_in;\n                4'b1000: stage2 <= {data_in[7:0], stage1[7:0]};\n                default: stage2 <= stage1;\n            endcase\n            \n            data_out <= stage2;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes and optimizes data processing paths by identifying bottlenecks, eliminating redundant operations, and restructuring data flow for better efficiency.\n\nCode:\n```verilog\nmodule complex_datapath_before (\n    input clk, rst,\n    input [31:0] data_in,\n    input [2:0] op_sel,\n    output reg [31:0] data_out\n);\n    // Complex data processing with redundant stages\n    reg [31:0] stage1, stage2, stage3, stage4;\n    reg [15:0] temp1, temp2;\n    reg [7:0] byte1, byte2;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 32'd0;\n            stage2 <= 32'd0;\n            stage3 <= 32'd0;\n            stage4 <= 32'd0;\n            data_out <= 32'd0;\n        end else begin\n            // Stage 1: Unnecessary data splitting\n            stage1 <= data_in;\n            temp1 <= data_in[31:16];\n            temp2 <= data_in[15:0];\n            byte1 <= data_in[7:0];\n            byte2 <= data_in[15:8];\n            \n            // Stage 2: Redundant operations\n            stage2 <= stage1;\n            case (op_sel[0])\n                1'b0: stage2 <= {temp1, temp2};\n                1'b1: stage2 <= {temp2, temp1};\n            endcase\n            \n            // Stage 3: Inefficient byte operations\n            stage3 <= stage2;\n            case (op_sel[1])\n                1'b0: stage3 <= {byte1, byte2, stage2[15:0]};\n                1'b1: stage3 <= {stage2[31:16], byte2, byte1};\n            endcase\n            \n            // Stage 4: Final processing\n            stage4 <= stage3;\n            case (op_sel[2])\n                1'b0: stage4 <= stage3 << 1;\n                1'b1: stage4 <= stage3 >> 1;\n            endcase\n            \n            data_out <= stage4;\n        end\n    end\nendmodule\n```", "output": "module complex_datapath_after (\n    input clk, rst,\n    input [31:0] data_in,\n    input [2:0] op_sel,\n    output reg [31:0] data_out\n);\n    // Optimized data processing with direct operations\n    reg [31:0] stage1, stage2;\n    \n    // Efficient data processing with minimal stages\n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 32'd0;\n            stage2 <= 32'd0;\n            data_out <= 32'd0;\n        end else begin\n            // Stage 1: Direct data manipulation\n            case (op_sel[1:0])\n                2'b00: stage1 <= data_in;\n                2'b01: stage1 <= {data_in[15:0], data_in[31:16]};\n                2'b10: stage1 <= {data_in[7:0], data_in[15:8], data_in[31:16]};\n                2'b11: stage1 <= {data_in[31:16], data_in[15:8], data_in[7:0]};\n            endcase\n            \n            // Stage 2: Final shift operation\n            case (op_sel[2])\n                1'b0: stage2 <= stage1 << 1;\n                1'b1: stage2 <= stage1 >> 1;\n            endcase\n            \n            data_out <= stage2;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes and optimizes timing paths in the design by identifying critical paths, balancing logic delays, and implementing efficient timing closure techniques.\n\nCode:\n```verilog\nmodule timing_before (\n    input clk, rst,\n    input [15:0] data_in,\n    input [3:0] control,\n    output reg [15:0] data_out\n);\n    // Long critical path with unbalanced logic\n    reg [15:0] stage1, stage2;\n    wire [15:0] processed_data;\n    \n    // Complex combinational logic in single cycle\n    assign processed_data = (data_in & stage1) | \n                          (data_in ^ stage1) |\n                          (data_in + stage1) |\n                          (data_in - stage1);\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 16'd0;\n            stage2 <= 16'd0;\n            data_out <= 16'd0;\n        end else begin\n            // Long critical path\n            stage1 <= data_in;\n            stage2 <= processed_data;\n            data_out <= stage2;\n        end\n    end\nendmodule\n```", "output": "module timing_after (\n    input clk, rst,\n    input [15:0] data_in,\n    input [3:0] control,\n    output reg [15:0] data_out\n);\n    // Balanced pipeline stages\n    reg [15:0] stage1, stage2, stage3;\n    wire [15:0] processed_data1, processed_data2;\n    \n    // Split complex logic into balanced stages\n    assign processed_data1 = (data_in & stage1) | (data_in ^ stage1);\n    assign processed_data2 = (data_in + stage1) | (data_in - stage1);\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 16'd0;\n            stage2 <= 16'd0;\n            stage3 <= 16'd0;\n            data_out <= 16'd0;\n        end else begin\n            // Balanced pipeline stages\n            stage1 <= data_in;\n            stage2 <= processed_data1 | processed_data2;\n            stage3 <= stage2;\n            data_out <= stage3;\n        end\n    end\nendmodule"}
{"instruction": "Based on the provided optimization rule, optimize the following Verilog code to improve PPA (Power, Performance, Area).", "input": "Rule: This optimization analyzes and optimizes timing paths in the design by identifying critical paths, balancing logic delays, and implementing efficient timing closure techniques.\n\nCode:\n```verilog\nmodule complex_timing_before (\n    input clk, rst,\n    input [31:0] data_in,\n    input [2:0] op_sel,\n    output reg [31:0] data_out\n);\n    // Complex timing paths with unbalanced logic\n    reg [31:0] stage1, stage2;\n    wire [31:0] mult_result, add_result, shift_result;\n    \n    // Complex combinational logic\n    assign mult_result = data_in * stage1;\n    assign add_result = data_in + stage1;\n    assign shift_result = data_in << stage1[4:0];\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 32'd0;\n            stage2 <= 32'd0;\n            data_out <= 32'd0;\n        end else begin\n            // Long critical path\n            stage1 <= data_in;\n            case (op_sel)\n                3'b000: stage2 <= mult_result;\n                3'b001: stage2 <= add_result;\n                3'b010: stage2 <= shift_result;\n                3'b011: stage2 <= mult_result + add_result;\n                3'b100: stage2 <= mult_result + shift_result;\n                3'b101: stage2 <= add_result + shift_result;\n                3'b110: stage2 <= mult_result + add_result + shift_result;\n                3'b111: stage2 <= 32'd0;\n            endcase\n            data_out <= stage2;\n        end\n    end\nendmodule\n```", "output": "module complex_timing_after (\n    input clk, rst,\n    input [31:0] data_in,\n    input [2:0] op_sel,\n    output reg [31:0] data_out\n);\n    // Balanced pipeline stages\n    reg [31:0] stage1, stage2, stage3;\n    wire [31:0] mult_result, add_result, shift_result;\n    \n    // Split complex logic into balanced stages\n    assign mult_result = data_in * stage1;\n    assign add_result = data_in + stage1;\n    assign shift_result = data_in << stage1[4:0];\n    \n    // Intermediate results\n    reg [31:0] mult_reg, add_reg, shift_reg;\n    reg [31:0] sum1_reg, sum2_reg;\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            stage1 <= 32'd0;\n            stage2 <= 32'd0;\n            stage3 <= 32'd0;\n            data_out <= 32'd0;\n            mult_reg <= 32'd0;\n            add_reg <= 32'd0;\n            shift_reg <= 32'd0;\n            sum1_reg <= 32'd0;\n            sum2_reg <= 32'd0;\n        end else begin\n            // Stage 1: Input registration\n            stage1 <= data_in;\n            \n            // Stage 2: Basic operations\n            mult_reg <= mult_result;\n            add_reg <= add_result;\n            shift_reg <= shift_result;\n            \n            // Stage 3: Intermediate sums\n            case (op_sel[1:0])\n                2'b00: sum1_reg <= mult_reg;\n                2'b01: sum1_reg <= add_reg;\n                2'b10: sum1_reg <= shift_reg;\n                2'b11: sum1_reg <= mult_reg + add_reg;\n            endcase\n            \n            // Stage 4: Final result\n            case (op_sel[2])\n                1'b0: data_out <= sum1_reg;\n                1'b1: data_out <= sum1_reg + shift_reg;\n            endcase\n        end\n    end\nendmodule"}
{"instruction": "Optimize the following Verilog module by removing redundant assignments to improve logic efficiency.", "input": "module redundant_assign (\n    input wire a,\n    input wire b,\n    output wire out1,\n    output wire out2\n);\n\n    wire temp_wire;\n\n    assign temp_wire = a & b;\n    assign out1 = temp_wire;\n    assign out2 = temp_wire; \n\nendmodule", "output": "module redundant_assign (\n    input wire a,\n    input wire b,\n    output wire out1,\n    output wire out2\n);\n\n    assign out1 = a & b;\n    assign out2 = a & b;\n\nendmodule"}
{"instruction": "Refactor the case statement to use parallel_case attribute for better synthesis performance on FPGAs.", "input": "module parallel_case_example(\n    input [2:0] select,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(*) begin\n        case (select)\n            3'b001: data_out = data_in + 8'd1;\n            3'b010: data_out = data_in + 8'd2;\n            3'b100: data_out = data_in + 8'd3;\n            default: data_out = data_in;\n        endcase\n    end\n\nendmodule", "output": "module parallel_case_example(\n    input [2:0] select,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(*) begin\n        // synopsys parallel_case\n        case (select)\n            3'b001: data_out = data_in + 8'd1;\n            3'b010: data_out = data_in + 8'd2;\n            3'b100: data_out = data_in + 8'd3;\n            default: data_out = data_in;\n        endcase\n    end\n\nendmodule"}
{"instruction": "Merge the two always blocks that drive the same register 'q' to prevent synthesis issues and improve clarity.", "input": "module merge_always_blocks(\n    input clk,\n    input reset,\n    input d1,\n    input d2,\n    input sel,\n    output reg q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (sel)\n            q <= d1;\n        else\n            q <= d2;\n    end\n\nendmodule", "output": "module merge_always_blocks(\n    input clk,\n    input reset,\n    input d1,\n    input d2,\n    input sel,\n    output reg q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            if (sel)\n                q <= d1;\n            else\n                q <= d2;\n        end\n    end\n\nendmodule"}
{"instruction": "Optimize the multiplier by using bit-shifting for multiplication by a power of 2, which is more efficient in hardware.", "input": "module mult_by_four(\n    input [7:0] data_in,\n    output [9:0] data_out\n);\n\n    assign data_out = data_in * 4;\n\nendmodule", "output": "module mult_by_four(\n    input [7:0] data_in,\n    output [9:0] data_out\n);\n\n    assign data_out = {data_in, 2'b00};\n\nendmodule"}
{"instruction": "Retiming optimization: Move the register stage from the output to the inputs of the adder to break the critical path and improve timing.", "input": "module retiming_before (\n    input clk,\n    input [15:0] a, b, c, d,\n    output reg [17:0] result\n);\n    wire [16:0] sum1, sum2;\n    assign sum1 = a + b;\n    assign sum2 = c + d;\n\n    always @(posedge clk) begin\n        result <= sum1 + sum2;\n    end\nendmodule", "output": "module retiming_after (\n    input clk,\n    input [15:0] a, b, c, d,\n    output [17:0] result\n);\n    reg [15:0] a_reg, b_reg, c_reg, d_reg;\n    always @(posedge clk) begin\n        a_reg <= a;\n        b_reg <= b;\n        c_reg <= c;\n        d_reg <= d;\n    end\n\n    assign result = (a_reg + b_reg) + (c_reg + d_reg);\nendmodule"}
{"instruction": "Apply constant propagation to simplify the logic.", "input": "module const_prop_before(\n    input [7:0] in,\n    output [7:0] out\n);\n    localparam ENABLE = 1'b1;\n    localparam ADD_VAL = 8'd5;\n    wire [7:0] temp;\n\n    assign temp = ENABLE ? in : 8'd0;\n    assign out = temp + ADD_VAL;\nendmodule", "output": "module const_prop_after(\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = in + 8'd5;\nendmodule"}
{"instruction": "Reduce the bit-width of the adder based on the known maximum value of the inputs to save area.", "input": "module width_reduction_before(\n    // Inputs are known to be <= 15\n    input [7:0] a, \n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule", "output": "module width_reduction_after(\n    // Inputs are known to be <= 15\n    input [7:0] a, \n    input [7:0] b,\n    output [8:0] sum\n);\n    wire [4:0] smaller_sum;\n    assign smaller_sum = a[3:0] + b[3:0];\n    assign sum = {4'b0, smaller_sum};\nendmodule"}
{"instruction": "Convert the blocking assignments to non-blocking assignments inside the sequential always block to prevent simulation races.", "input": "module blocking_to_nonblocking(\n  input clk,\n  input reset,\n  input d,\n  output q, q_delayed\n);\n  reg q, q_delayed;\n\n  always @(posedge clk) begin\n    if (reset)\n      q = 1'b0;\n    else\n      q = d;\n\n    q_delayed = q; // Blocking assignment creates a race\n  end\nendmodule", "output": "module blocking_to_nonblocking(\n  input clk,\n  input reset,\n  input d,\n  output q, q_delayed\n);\n  reg q, q_delayed;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      q <= 1'b0;\n      q_delayed <= 1'b0;\n    end else begin\n      q <= d;\n      q_delayed <= q; // Non-blocking creates proper pipeline stage\n    end\n  end\nendmodule"}
{"instruction": "Factor out the common subexpression 'a & b' to reduce logic duplication.", "input": "module cse_before(\n    input a, b, c, d,\n    output out1, out2\n);\n    assign out1 = (a & b) & c;\n    assign out2 = (a & b) | d;\nendmodule", "output": "module cse_after(\n    input a, b, c, d,\n    output out1, out2\n);\n    wire common_expr = a & b;\n    assign out1 = common_expr & c;\n    assign out2 = common_expr | d;\nendmodule"}
{"instruction": "Optimize the state machine encoding from one-hot to binary to reduce the number of flip-flops required.", "input": "module fsm_onehot(\n    // ... fsm logic ...\n);\n    localparam S0 = 4'b0001;\n    localparam S1 = 4'b0010;\n    localparam S2 = 4'b0100;\n    localparam S3 = 4'b1000;\n    reg [3:0] state, next_state;\n    // ... fsm body ...\nendmodule", "output": "module fsm_binary(\n    // ... fsm logic ...\n);\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n    localparam S3 = 2'b11;\n    reg [1:0] state, next_state;\n    // ... fsm body ...\nendmodule"}
{"instruction": "Re-balance the expression tree by changing associativity to shorten the critical path from input 'a' to the output.", "input": "module expression_balance_before(\n    input [7:0] a, b, c, d;\n    output [10:0] out;\n    assign out = ((a + b) + c) + d;\nendmodule", "output": "module expression_balance_after(\n    input [7:0] a, b, c, d;\n    output [10:0] out;\n    assign out = (a + b) + (c + d);\nendmodule"}
{"instruction": "Replace the integer division by a power of two with a more efficient arithmetic right shift operation.", "input": "module div_by_power_of_2(\n    input signed [15:0] data_in,\n    output signed [15:0] data_out\n);\n    assign data_out = data_in / 16;\nendmodule", "output": "module div_by_power_of_2(\n    input signed [15:0] data_in,\n    output signed [15:0] data_out\n);\n    assign data_out = data_in >>> 4;\nendmodule"}
{"instruction": "Implement a 'full_case' pragma to prevent the synthesis of unintended latches for the incomplete case statement.", "input": "module full_case_needed(\n    input [1:0] sel,\n    input a, b,\n    output reg y\n);\n    always @(*) begin\n        case (sel)\n            2'b01: y = a;\n            2'b10: y = b;\n        endcase\n    end\nendmodule", "output": "module full_case_added(\n    input [1:0] sel,\n    input a, b,\n    output reg y\n);\n    always @(*) begin\n        // synopsys full_case\n        case (sel)\n            2'b01: y = a;\n            2'b10: y = b;\n            default: y = 1'bx; // Prevent latch, define default behavior\n        endcase\n    end\nendmodule"}
{"instruction": "Optimize for area by sharing a single multiplier resource across two operations, controlled by a select signal.", "input": "module resource_sharing_before(\n    input [7:0] a, b, c, d,\n    input sel,\n    output [15:0] result\n);\n    wire [15:0] mul1 = a * b;\n    wire [15:0] mul2 = c * d;\n    assign result = sel ? mul1 : mul2;\nendmodule", "output": "module resource_sharing_after(\n    input [7:0] a, b, c, d,\n    input sel,\n    output [15:0] result\n);\n    wire [7:0] operand1 = sel ? a : c;\n    wire [7:0] operand2 = sel ? b : d;\n    assign result = operand1 * operand2;\nendmodule"}
{"instruction": "Simplify the boolean expression by removing the redundant term using absorption law (A or (A and B) = A).", "input": "module absorption_law(\n    input a, b,\n    output y\n);\n    assign y = a | (a & b);\nendmodule", "output": "module absorption_law(\n    input a, b,\n    output y\n);\n    assign y = a;\nendmodule"}
{"instruction": "Introduce a pipeline register to break a long combinational path involving a multiplication and an addition.", "input": "module pipeline_adder_mult(\n    input clk,\n    input [7:0] a, b, c,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        result <= (a * b) + c;\n    end\nendmodule", "output": "module pipeline_adder_mult(\n    input clk,\n    input [7:0] a, b, c,\n    output reg [15:0] result\n);\n    reg [15:0] mult_result;\n    always @(posedge clk) begin\n        mult_result <= a * b;\n        result <= mult_result + c;\n    end\nendmodule"}
{"instruction": "Apply De Morgan's theorem to the expression, which may lead to a better implementation on some technology nodes.", "input": "module demorgan_before(\n    input a, b,\n    output y\n);\n    assign y = ~(a & b);\nendmodule", "output": "module demorgan_after(\n    input a, b,\n    output y\n);\n    assign y = ~a | ~b;\nendmodule"}
{"instruction": "Remove the unused register 'unused_reg' to save area.", "input": "module remove_unused_logic(\n    input clk,\n    input d,\n    output reg q\n);\n    reg unused_reg;\n    always @(posedge clk) begin\n        q <= d;\n        unused_reg <= d & q;\n    end\nendmodule", "output": "module remove_unused_logic(\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"instruction": "Use a generate block to create a scalable chain of N registers.", "input": "module manual_shift_register(\n    input clk, din,\n    output dout\n);\n    reg r1, r2, r3, r4;\n    always @(posedge clk) begin\n        r1 <= din;\n        r2 <= r1;\n        r3 <= r2;\n        r4 <= r3;\n    end\n    assign dout = r4;\nendmodule", "output": "module generated_shift_register #(\n    parameter WIDTH = 4\n) (\n    input clk, din,\n    output dout\n);\n    reg [WIDTH-1:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[WIDTH-2:0], din};\n    end\n    assign dout = shift_reg[WIDTH-1];\nendmodule"}
{"instruction": "Convert the complex conditional assignment into a simpler ternary operator for readability and potentially better synthesis.", "input": "module complex_if_to_ternary(\n    input sel1, sel2,\n    input [7:0] a, b, c,\n    output reg [7:0] y\n);\n    always@(*) begin\n        if(sel1) begin\n            if(sel2) y = a;\n            else y = b;\n        end else y = c;\n    end\nendmodule", "output": "module complex_if_to_ternary(\n    input sel1, sel2,\n    input [7:0] a, b, c,\n    output [7:0] y\n);\n    assign y = sel1 ? (sel2 ? a : b) : c;\nendmodule"}
{"instruction": "Change the state machine encoding from binary to Gray code to reduce glitches and power consumption during state transitions.", "input": "module fsm_binary_encoding(\n    // ... fsm logic ...\n);\n    parameter S0=2'b00, S1=2'b01, S2=2'b10;\n    reg [1:0] state;\n    // ...\nendmodule", "output": "module fsm_gray_encoding(\n    // ... fsm logic ...\n);\n    parameter S0=2'b00, S1=2'b01, S2=2'b11;\n    reg [1:0] state;\n    // ...\nendmodule"}
{"instruction": "Infer a Block RAM by using a synchronous read in the memory model, which is more efficient on FPGAs.", "input": "module memory_async_read(\n    input clk, we,\n    input [7:0] addr,\n    input [31:0] din,\n    output [31:0] dout\n);\n    reg [31:0] mem [255:0];\n    always @(posedge clk) begin\n        if (we) mem[addr] <= din;\n    end\n    assign dout = mem[addr]; // Asynchronous read\nendmodule", "output": "module memory_sync_read(\n    input clk, we,\n    input [7:0] addr,\n    input [31:0] din,\n    output reg [31:0] dout\n);\n    // synopsys ram_style = \"block\"\n    reg [31:0] mem [255:0];\n    always @(posedge clk) begin\n        if (we) mem[addr] <= din;\n        dout <= mem[addr]; // Synchronous read\n    end\nendmodule"}
{"instruction": "Duplicate a register to reduce the high fanout on signal 'control_sig', improving timing.", "input": "module high_fanout_before(\n    input clk, d,\n    output o1, o2, o3, o4, o5, o6\n);\n    reg control_sig;\n    always @(posedge clk) control_sig <= d;\n    assign o1 = control_sig & d;\n    assign o2 = control_sig | d;\n    assign o3 = control_sig ^ d;\n    assign o4 = ~control_sig;\n    assign o5 = control_sig & ~d;\n    assign o6 = d;\nendmodule", "output": "module high_fanout_after(\n    input clk, d,\n    output o1, o2, o3, o4, o5, o6\n);\n    reg control_sig_1, control_sig_2;\n    always @(posedge clk) begin\n        control_sig_1 <= d;\n        control_sig_2 <= d;\n    end\n    assign o1 = control_sig_1 & d;\n    assign o2 = control_sig_1 | d;\n    assign o3 = control_sig_1 ^ d;\n    assign o4 = ~control_sig_2;\n    assign o5 = control_sig_2 & ~d;\n    assign o6 = d;\nendmodule"}
{"instruction": "Remove identity multiplication by 1.", "input": "module identity_mult(\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n    assign data_out = data_in * 1;\nendmodule", "output": "module identity_mult(\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n    assign data_out = data_in;\nendmodule"}
{"instruction": "Simplify the conditional logic, as the condition 'sel == 1' is equivalent to just 'sel' for a 1-bit signal.", "input": "module simplify_condition(\n    input sel,\n    input [7:0] a, b,\n    output [7:0] y\n);\n    assign y = (sel == 1'b1) ? a : b;\nendmodule", "output": "module simplify_condition(\n    input sel,\n    input [7:0] a, b,\n    output [7:0] y\n);\n    assign y = sel ? a : b;\nendmodule"}
{"instruction": "Replace an addition of zero with a direct assignment.", "input": "module identity_add(\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n    assign data_out = data_in + 0;\nendmodule", "output": "module identity_add(\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n    assign data_out = data_in;\nendmodule"}
{"instruction": "Optimize the comparator logic by removing the unnecessary comparison to zero.", "input": "module comparator_z(\n    input [3:0] in,\n    output is_zero\n);\n    assign is_zero = (in == 4'b0000);\nendmodule", "output": "module comparator_z_opt(\n    input [3:0] in,\n    output is_zero\n);\n    assign is_zero = ~|in;\nendmodule"}
{"instruction": "Unroll the loop to improve performance for small, fixed loop counts, reducing loop overhead in the hardware.", "input": "module loop_unroll_before(\n    input [3:0] a, b, c, d,\n    output reg [5:0] sum\n);\n    integer i;\n    always @(*) begin\n        sum = 0;\n        for (i = 0; i < 4; i = i + 1) begin\n            // This style is not ideal for synthesis\n        end\n    end\nendmodule", "output": "module loop_unroll_after(\n    input [3:0] a, b, c, d,\n    output [5:0] sum\n);\n    assign sum = a + b + c + d;\nendmodule"}
{"instruction": "Change synchronous reset to asynchronous reset for faster reset recovery.", "input": "module sync_reset (\n    input clk, reset, d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (reset)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule", "output": "module async_reset (\n    input clk, reset, d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"instruction": "Remove redundant parentheses from the expression.", "input": "module redundant_paren(\n    input [7:0] a, b, c,\n    output [7:0] y\n);\n    assign y = (a + b) + c;\nendmodule", "output": "module redundant_paren(\n    input [7:0] a, b, c,\n    output [7:0] y\n);\n    assign y = a + b + c;\nendmodule"}
{"instruction": "Simplify the logic `A and not A` which is always false.", "input": "module always_false(\n    input a,\n    output y\n);\n    assign y = a & ~a;\nendmodule", "output": "module always_false(\n    input a,\n    output y\n);\n    assign y = 1'b0;\nendmodule"}
{"instruction": "Simplify the logic `A or not A` which is always true.", "input": "module always_true(\n    input a,\n    output y\n);\n    assign y = a | ~a;\nendmodule", "output": "module always_true(\n    input a,\n    output y\n);\n    assign y = 1'b1;\nendmodule"}
{"instruction": "Use concatenation to perform a bit shift left by 1.", "input": "module shift_by_concat(\n    input [6:0] d_in,\n    output [7:0] d_out\n);\n    assign d_out = d_in * 2;\nendmodule", "output": "module shift_by_concat(\n    input [6:0] d_in,\n    output [7:0] d_out\n);\n    assign d_out = {d_in, 1'b0};\nendmodule"}
{"instruction": "Optimize the one-hot checker by using a bitwise AND reduction.", "input": "module onehot_check_if(\n    input [3:0] in,\n    output is_onehot\n);\n    assign is_onehot = (in == 4'b0001) || (in == 4'b0010) || (in == 4'b0100) || (in == 4'b1000);\nendmodule", "output": "module onehot_check_popcount(\n    input [3:0] in,\n    output is_onehot\n);\n    // A more scalable way is to check population count\n    assign is_onehot = ($countones(in) == 1);\nendmodule"}
{"instruction": "Convert the `if-else` chain into a `case` statement for better readability and potentially better synthesis for multi-bit selects.", "input": "module if_to_case(\n    input [1:0] sel,\n    input [3:0] a, b, c, d,\n    output reg [3:0] out\n);\n    always @(*) begin\n        if (sel == 2'b00) out = a;\n        else if (sel == 2'b01) out = b;\n        else if (sel == 2'b10) out = c;\n        else out = d;\n    end\nendmodule", "output": "module if_to_case(\n    input [1:0] sel,\n    input [3:0] a, b, c, d,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            2'b00: out = a;\n            2'b01: out = b;\n            2'b10: out = c;\n            default: out = d;\n        endcase\n    end\nendmodule"}
{"instruction": "Simplify the expression by applying the identity `A XOR 0 = A`.", "input": "module xor_identity(\n    input a,\n    output y\n);\n    assign y = a ^ 1'b0;\nendmodule", "output": "module xor_identity(\n    input a,\n    output y\n);\n    assign y = a;\nendmodule"}
{"instruction": "Simplify the expression by applying the identity `A XOR A = 0`.", "input": "module xor_self(\n    input a,\n    output y\n);\n    assign y = a ^ a;\nendmodule", "output": "module xor_self(\n    input a,\n    output y\n);\n    assign y = 1'b0;\nendmodule"}
{"instruction": "Extract the most significant bit (MSB) using a right shift.", "input": "module get_msb_manual(\n    input [7:0] data,\n    output msb\n);\n    assign msb = data[7];\nendmodule", "output": "module get_msb_shift(\n    input [7:0] data,\n    output msb\n);\n    assign msb = data >> 7;\nendmodule"}
{"instruction": "Use a tristate buffer for a bidirectional pin.", "input": "module bidir_pin_mux(\n    input oe, data_out,\n    inout wire pin,\n    output wire data_in\n);\n    assign pin = oe ? data_out : 1'bz;\n    assign data_in = pin;\nendmodule", "output": "module bidir_pin_assign(\n    input oe, data_out,\n    inout wire pin,\n    output wire data_in\n);\n    assign pin = oe ? data_out : 1'bz;\n    assign data_in = oe ? 1'bx : pin; // Don't read when driving\nendmodule"}
{"instruction": "Optimize the parity check logic using a bitwise XOR reduction.", "input": "module parity_check_manual(\n    input [3:0] data,\n    output parity\n);\n    assign parity = data[0] ^ data[1] ^ data[2] ^ data[3];\nendmodule", "output": "module parity_check_reduction(\n    input [3:0] data,\n    output parity\n);\n    assign parity = ^data;\nendmodule"}
{"instruction": "Replace chained single-bit adders with a multi-bit adder.", "input": "module chained_adders(\n    input a0, b0, a1, b1,\n    output s0, s1, cout\n);\n    wire c1;\n    assign {c1, s0} = a0 + b0;\n    assign {cout, s1} = a1 + b1 + c1;\nendmodule", "output": "module multi_bit_adder(\n    input [1:0] a, b,\n    output [1:0] s,\n    output cout\n);\n    assign {cout, s} = a + b;\nendmodule"}
{"instruction": "Use a parameterized module to define the size of the counter.", "input": "module fixed_counter(\n    input clk, rst,\n    output reg [3:0] count\n);\n    always @(posedge clk) if(rst) count <= 0; else count <= count + 1;\nendmodule", "output": "module param_counter #(\n    parameter WIDTH = 4\n) (\n    input clk, rst,\n    output reg [WIDTH-1:0] count\n);\n    always @(posedge clk) if(rst) count <= 0; else count <= count + 1;\nendmodule"}
{"instruction": "Simplify the multiplexer logic where the select signal is constant.", "input": "module mux_const_sel(\n    input [7:0] a, b,\n    output [7:0] y\n);\n    localparam SELECT_A = 1;\n    assign y = SELECT_A ? a : b;\nendmodule", "output": "module mux_const_sel(\n    input [7:0] a, b,\n    output [7:0] y\n);\n    assign y = a;\nendmodule"}
{"instruction": "Flatten nested if-statements into a single if-statement with a compound condition.", "input": "module nested_if(\n    input a, b, c, d,\n    output reg y\n);\n    always @(*) begin\n        if (a)\n            if (b)\n                y = d;\n            else y = c;\n        else y = c;\n    end\nendmodule", "output": "module flat_if(\n    input a, b, c, d,\n    output reg y\n);\n    always @(*) begin\n        if (a && b)\n            y = d;\n        else\n            y = c;\n    end\nendmodule"}
{"instruction": "Optimize signed comparison to avoid explicit sign bit checking.", "input": "module signed_compare_manual(\n    input signed [7:0] a,\n    output is_negative\n);\n    assign is_negative = (a[7] == 1'b1);\nendmodule", "output": "module signed_compare_direct(\n    input signed [7:0] a,\n    output is_negative\n);\n    assign is_negative = (a < 0);\nendmodule"}
{"instruction": "Propagate bit replication through logic.", "input": "module bit_replicate_prop(\n    input a,\n    output [3:0] y\n);\n    wire [3:0] a_rep = {4{a}};\n    assign y = a_rep;\nendmodule", "output": "module bit_replicate_prop(\n    input a,\n    output [3:0] y\n);\n    assign y = {4{a}};\nendmodule"}
{"instruction": "Replace a counter with a Linear Feedback Shift Register (LFSR) for a pseudo-random sequence.", "input": "module standard_counter(\n    input clk, rst,\n    output reg [3:0] count\n);\n    always @(posedge clk, posedge rst)\n        if (rst) count <= 4'h1;\n        else count <= count + 1;\nendmodule", "output": "module lfsr_counter(\n    input clk, rst,\n    output reg [3:0] lfsr\n);\n    wire feedback = lfsr[3] ^ lfsr[2];\n    always @(posedge clk, posedge rst)\n        if (rst) lfsr <= 4'h1;\n        else lfsr <= {lfsr[2:0], feedback};\nendmodule"}
{"instruction": "Replace sequential logic with a direct combinational path if the register is read in the same clock cycle it's written (incorrect coding style).", "input": "module seq_to_comb(\n    input clk, a, b,\n    output y\n);\n    reg temp;\n    always @(posedge clk) begin\n        temp <= a & b;\n    end\n    assign y = temp;\nendmodule", "output": "module seq_to_comb(\n    input clk, a, b,\n    output y\n);\n    assign y = a & b;\nendmodule"}
{"instruction": "Use bit masking instead of a conditional assignment for setting lower bits.", "input": "module conditional_mask(\n    input [7:0] data,\n    input enable,\n    output [7:0] result\n);\n    assign result = enable ? {data[7:4], 4'b0} : data;\nendmodule", "output": "module bit_mask(\n    input [7:0] data,\n    input enable,\n    output [7:0] result\n);\n    wire [7:0] mask = {4'b1111, {4{!enable}}};\n    assign result = data & mask;\nendmodule"}
{"instruction": "Merge two comparators into a single range check.", "input": "module separate_comparators(\n    input [3:0] val,\n    output in_range\n);\n    wire gt_3 = val > 3;\n    wire lt_8 = val < 8;\n    assign in_range = gt_3 & lt_8;\nendmodule", "output": "module range_check(\n    input [3:0] val,\n    output in_range\n);\n    assign in_range = (val > 3) && (val < 8);\nendmodule"}
{"instruction": "Optimize the reset logic by assigning a constant value directly.", "input": "module reset_logic(\n    input clk, rst, d,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (rst) q <= 1'b0;\n        else q <= d;\n    end\nendmodule", "output": "module reset_logic_opt(\n    input clk, rst, d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= rst ? 1'b0 : d;\n    end\nendmodule"}
{"instruction": "Remove an identity assignment through a wire.", "input": "module identity_wire(\n    input [7:0] a,\n    output [7:0] b\n);\n    wire [7:0] temp = a;\n    assign b = temp;\nendmodule", "output": "module identity_wire(\n    input [7:0] a,\n    output [7:0] b\n);\n    assign b = a;\nendmodule"}
{"instruction": "Simplify a case statement with only one active branch.", "input": "module simple_case(\n    input [1:0] sel, \n    input [7:0] d,\n    output reg [7:0] q\n);\n    localparam ACTIVE = 2'b10;\n    always @(*) begin\n        case(sel)\n            ACTIVE: q = d;\n            default: q = 8'd0;\n        endcase\n    end\nendmodule", "output": "module simple_case_opt(\n    input [1:0] sel, \n    input [7:0] d,\n    output [7:0] q\n);\n    assign q = (sel == 2'b10) ? d : 8'd0;\nendmodule"}
{"instruction": "Replace a `for` loop in combinational logic with a direct vector operation.", "input": "module for_loop_vector_or(\n    input [3:0] a, b,\n    output reg [3:0] y\n);\n    integer i;\n    always @(*) begin\n        for (i=0; i<4; i=i+1) begin\n            y[i] = a[i] | b[i];\n        end\n    end\nendmodule", "output": "module for_loop_vector_or(\n    input [3:0] a, b,\n    output [3:0] y\n);\n    assign y = a | b;\nendmodule"}
{"instruction": "Use a single assignment for initializing multiple registers in a reset condition.", "input": "module multi_reg_reset(\n    input clk, rst,\n    output reg r1, r2, r3\n);\n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            r1 <= 1'b0;\n            r2 <= 1'b0;\n            r3 <= 1'b0;\n        end\n    end\nendmodule", "output": "module multi_reg_reset_opt(\n    input clk, rst,\n    output reg r1, r2, r3\n);\n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            {r1, r2, r3} <= 3'b000;\n        end\n    end\nendmodule"}
{"instruction": "Expand the bit-width of an output port to match the internal adder's full precision, preventing silent overflow.", "input": "module overflow_error(\n    input [7:0] a, b,\n    output [7:0] sum // Potential overflow\n);\n    assign sum = a + b;\nendmodule", "output": "module no_overflow(\n    input [7:0] a, b,\n    output [8:0] sum // Corrected width\n);\n    assign sum = a + b;\nendmodule"}
{"instruction": "Specialize the module for a fixed parameter, removing the parameterization.", "input": "module generic_shifter #(\n    parameter SHIFT_AMT = 3\n) (\n    input [15:0] d_in,\n    output [15:0] d_out\n);\n    assign d_out = d_in << SHIFT_AMT;\nendmodule", "output": "module fixed_shifter_by_3 (\n    input [15:0] d_in,\n    output [15:0] d_out\n);\n    assign d_out = d_in << 3;\nendmodule"}
{"instruction": "Remove dead code within an `if (0)` block.", "input": "module dead_code_if_zero(\n    input a, b,\n    output reg y\n);\n    always@(*) begin\n        if (1'b0) begin\n            y = a; // This is dead code\n        end else begin\n            y = b;\n        end\n    end\nendmodule", "output": "module dead_code_if_zero(\n    input a, b,\n    output y\n);\n    assign y = b;\nendmodule"}
{"instruction": "Reorder operands in a commutative operation to match a canonical form, potentially enabling more downstream optimizations.", "input": "module canonical_form(\n    input [7:0] a, b,\n    output [7:0] y\n);\n    // Assume canonical form is constants on the right\n    assign y = 5 + a;\nendmodule", "output": "module canonical_form(\n    input [7:0] a, b,\n    output [7:0] y\n);\n    // Assume canonical form is constants on the right\n    assign y = a + 5;\nendmodule"}
{"instruction": "Combine bit concatenations into a single concatenation.", "input": "module combine_concats(\n    input [3:0] a, b,\n    output [15:0] y\n);\n    wire [7:0] temp1 = {a, b};\n    wire [7:0] temp2 = {b, a};\n    assign y = {temp1, temp2};\nendmodule", "output": "module combine_concats(\n    input [3:0] a, b,\n    output [15:0] y\n);\n    assign y = {a, b, b, a};\nendmodule"}
{"instruction": "Optimize the finite state machine by merging equivalent states to reduce resource utilization.", "input": "module fsm_equivalent_states(\n    input clk, rst, in,\n    output reg out\n);\n    localparam S0=2'b00, S1=2'b01, S2=2'b10, S3=2'b11;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        out = 0;\n        next_state = state;\n        case (state)\n            S0: if (in) next_state = S1;\n            S1: begin\n                out = 1;\n                if (in) next_state = S3;\n                else next_state = S0;\n            end\n            S2: begin // S2 is equivalent to S1\n                out = 1;\n                if (in) next_state = S3;\n                else next_state = S0;\n            end\n            S3: if (in) next_state = S0;\n        endcase\n    end\nendmodule", "output": "module fsm_merged_states(\n    input clk, rst, in,\n    output reg out\n);\n    // S1 and S2 are merged into S1_MERGED\n    localparam S0=2'b00, S1_MERGED=2'b01, S3=2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        out = 0;\n        next_state = state;\n        case (state)\n            S0: if (in) next_state = S1_MERGED;\n            S1_MERGED: begin\n                out = 1;\n                if (in) next_state = S3;\n                else next_state = S0;\n            end\n            S3: if (in) next_state = S0;\n            default: next_state = S0;\n        endcase\n    end\nendmodule"}
{"instruction": "Optimize the finite state machine by removing unreachable states to reduce area and complexity.", "input": "module fsm_unreachable_state(\n    input clk, rst, in,\n    output reg [1:0] out\n);\n    localparam S0=3'b001, S1=3'b010, S2=3'b100; // S2 is unreachable\n    reg [2:0] state, next_state;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        out = 2'b00;\n        case (state)\n            S0: begin\n                out = 2'b01;\n                if(in) next_state = S1;\n            end\n            S1: begin\n                out = 2'b10;\n                if(in) next_state = S0;\n            end\n            S2: begin // This state is never reached\n                out = 2'b11;\n                next_state = S0;\n            end\n        endcase\n    end\nendmodule", "output": "module fsm_removed_unreachable(\n    input clk, rst, in,\n    output reg [1:0] out\n);\n    localparam S0=1'b0, S1=1'b1;\n    reg state, next_state;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) state <= S0;\n        else state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state;\n        out = 2'b00;\n        case (state)\n            S0: begin\n                out = 2'b01;\n                if(in) next_state = S1;\n            end\n            S1: begin\n                out = 2'b10;\n                if(in) next_state = S0;\n            end\n        endcase\n    end\nendmodule"}
{"instruction": "Refactor the code to infer a dedicated DSP hardware block for the multiply-accumulate (MAC) operation, improving performance and efficiency.", "input": "module mac_no_dsp(\n    input clk,\n    input signed [15:0] a, b,\n    input signed [31:0] c,\n    output signed [31:0] result\n);\n    wire signed [31:0] mul_res;\n    assign mul_res = a * b;\n    assign result = mul_res + c;\nendmodule", "output": "module mac_with_dsp(\n    input clk,\n    input signed [15:0] a, b,\n    input signed [31:0] c,\n    output reg signed [31:0] result\n);\n    // Registered inputs and output for DSP block inference\n    reg signed [15:0] a_reg, b_reg;\n    reg signed [31:0] c_reg;\n    always @(posedge clk) begin\n        a_reg <= a;\n        b_reg <= b;\n        c_reg <= c;\n        result <= (a_reg * b_reg) + c_reg;\n    end\nendmodule"}
{"instruction": "Optimize the shift register implementation to infer efficient SRL (Shift Register LUT) resources on FPGAs.", "input": "module standard_shift_reg(\n    input clk,\n    input din,\n    output dout\n);\n    reg r1, r2, r3, r4, r5, r6, r7, r8;\n    always @(posedge clk) begin\n        r1 <= din;\n        r2 <= r1;\n        r3 <= r2;\n        r4 <= r3;\n        r5 <= r4;\n        r6 <= r5;\n        r7 <= r6;\n        r8 <= r7;\n    end\n    assign dout = r8;\nendmodule", "output": "module srl_inferred_shift_reg #(\n    parameter DEPTH = 8\n) (\n    input clk,\n    input din,\n    output dout\n);\n    // This style with a memory array and a counter\n    // helps infer SRLs in Xilinx/Intel FPGAs.\n    reg [DEPTH-1:0] shift_mem;\n    always @(posedge clk) begin\n        shift_mem <= {shift_mem[DEPTH-2:0], din};\n    end\n    assign dout = shift_mem[DEPTH-1];\nendmodule"}
{"instruction": "Replace the expensive modulo operation with a more efficient bitwise AND operation since the divisor is a power of two.", "input": "module modulo_power_of_2(\n    input [7:0] data_in,\n    output [3:0] remainder\n);\n    assign remainder = data_in % 16;\nendmodule", "output": "module modulo_power_of_2_opt(\n    input [7:0] data_in,\n    output [3:0] remainder\n);\n    // For a divisor that is a power of 2 (2^N),\n    // modulo is equivalent to keeping the N LSBs.\n    assign remainder = data_in & 4'hF;\nendmodule"}
{"instruction": "Use a clock enable signal to reduce power consumption by preventing unnecessary state changes in registers, which can be simpler than explicit clock gating.", "input": "module register_bank_no_enable(\n    input clk, rst,\n    input [7:0] d1, d2, d3,\n    output reg [7:0] q1, q2, q3\n);\n    always @(posedge clk) begin\n        // Registers update every cycle, consuming power\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\nendmodule", "output": "module register_bank_with_enable(\n    input clk, rst, enable,\n    input [7:0] d1, d2, d3,\n    output reg [7:0] q1, q2, q3\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            q1 <= 8'd0;\n            q2 <= 8'd0;\n            q3 <= 8'd0;\n        end else if (enable) begin\n            // Registers only update when enabled\n            q1 <= d1;\n            q2 <= d2;\n            q3 <= d3;\n        end\n    end\nendmodule"}